# 核心问题与愿景

> 为什么需要 Singularity？它要解决什么问题？

---

## 一、现状痛点

### 痛点 1：三个维度无法兼得

| 库          | 简单吗？    | 可追踪吗？       | 细粒度更新？   |
| :---------- | :---------- | :--------------- | :------------- |
| **Zustand** | ✅ 极简     | ❌ 无内置追踪    | ❌ 需 selector |
| **Redux**   | ❌ 复杂     | ✅ DevTools 追踪 | ❌ 需手动优化  |
| **Jotai**   | ⚠️ 原子组合 | ❌ 无内置追踪    | ✅ 原生 Signal |
| **MobX**    | ⚠️ 中等     | ⚠️ 有限追踪      | ✅ Proxy       |

**问题不只是「二选一」，而是「三缺一」：**

- Zustand 简单但没追踪、没细粒度
- Redux 有追踪但太复杂
- Jotai 有细粒度但 API 是原子组合风格

### 痛点 1.5：为什么不能用插件解决？

| 问题                | 能用插件解决吗？ | 原因                            |
| :------------------ | :--------------- | :------------------------------ |
| 给 Zustand 加追踪   | ✅ 能            | 中间件已存在                    |
| 给 Jotai 加追踪     | ✅ 能            | devtools 已存在                 |
| 给 Zustand 加细粒度 | ❌ **不能**      | 架构决定（单 store + selector） |
| 给 Jotai 简化 API   | ❌ **不能**      | 原子组合是核心设计哲学          |

> **Zustand 的「非细粒度」是架构问题，不是功能问题。**
> **Jotai 的「原子组合」是设计哲学，不是可选配置。**

**所以需要从底层架构重新设计，这就是 Singularity。**

### 痛点 2：调试困难

```typescript
// 常见场景
user.name = 'Bob'; // 这行代码是谁写的？什么时候执行的？

// 一周后
PM：这个用户名为什么是 Bob？
开发：不知道…可能是某个异步回调改的？
```

**状态变化不可见 = 系统成为黑箱**

### 痛点 3：Redux 太重

```typescript
// Redux 写一个计数器需要：
// 1. 定义 Action Type
const INCREMENT = 'INCREMENT';

// 2. 定义 Action Creator
const increment = () => ({ type: INCREMENT });

// 3. 定义 Reducer
const reducer = (state = 0, action) => {
  switch (action.type) {
    case INCREMENT:
      return state + 1;
    default:
      return state;
  }
};

// 4. 配置 Store
const store = configureStore({ reducer });

// 5. 使用
dispatch(increment());
```

**只是想加个 1，写了 20 行代码。**

---

## 二、Singularity 的愿景

### 一句话

> **「天生简单，天生可追踪」**

### 核心承诺

| 承诺                  | 如何实现                               |
| :-------------------- | :------------------------------------- |
| **比 Zustand 更简单** | 一行代码创建状态，无需 `create()`      |
| **比 Redux 更可追踪** | 内置历史记录，无需配置 DevTools        |
| **比 Jotai 更易用**   | 同样细粒度更新，但 API 更简单          |
| **性能不打折**        | Signal 细粒度更新 + 生产模式零追踪开销 |

### 目标场景

```typescript
// Singularity：一行代码，开箱可追踪
const count = atom(0);
count.set(1);

// 出问题时
console.log(count.history());
// [{ from: 0, to: 1, time: '...', stack: '...' }]
```

---

## 三、核心哲学

> **「状态不是数据集合，而是可验证的变化史」**

### 四个原则

1. **可解释性 > 自由度**
   - 开发者可以随意写状态
   - 但系统必须能解释「为什么变成这样」

2. **因果闭环 > 局部便利**
   - 每次变更都有完整链条：触发 → 变化 → 记录
   - 不允许「无迹可寻」的状态突变

3. **开箱即用 > 需要配置**
   - 追踪默认开启
   - 不需要安装 DevTools 扩展

4. **演进性 > 一次性完美**
   - 小项目只用 `atom`
   - 大项目按需引入 `computed/effect`

---

## 四、不做什么

| 不纳入范围 | 理由               | 推荐方案        |
| :--------- | :----------------- | :-------------- |
| 服务端状态 | React Query 更专业 | TanStack Query  |
| 状态机     | XState 更成熟      | XState          |
| 表单状态   | 领域特化           | React Hook Form |
| 动画状态   | 领域特化           | Framer Motion   |

**原则：专注客户端状态 + 追踪，不重复造轮子。**

---

## 五、目标用户

| 用户类型             | 痛点                        | Singularity 的价值 |
| :------------------- | :-------------------------- | :----------------- |
| **想要简单的开发者** | Zustand 没追踪，出 bug 难查 | 简单 + 可追踪      |
| **想要追踪的开发者** | Redux 太复杂                | 追踪 + 简单        |
| **团队负责人**       | 成员代码难以追溯            | 所有变化可审计     |
| **调试困难的项目**   | 状态不知道何时被改          | 完整变化历史       |

---

## 六、成功标准

| 指标     | 目标        |
| :------- | :---------- |
| API 数量 | ≤ 5 个      |
| 学习时间 | ≤ 5 分钟    |
| 包体积   | ≤ 4KB       |
| 性能     | ≥ Jotai 80% |

---

_愿景文档 v2.0 - 2026-01-08_
